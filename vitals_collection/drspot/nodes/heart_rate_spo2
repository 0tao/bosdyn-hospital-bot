#!/usr/bin/env python

# Copyright 2020 Boston Dynamics Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

DEBUG_PLOT = False
DEBUG_IMAGE = False
DEBUG_SAVE_IMAGES = False
if DEBUG_PLOT:
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
if DEBUG_SAVE_IMAGES or DEBUG_PLOT:
    LOG_DIR = '/log'
    import os
import time

import numpy as np
import threading
import cv2
import math

import rospy
import message_filters
from sensor_msgs.msg import Image
from geometry_msgs.msg import PolygonStamped
from std_msgs.msg import Float32MultiArray, Float32, Bool
from cv_bridge import CvBridge

RED_IMAGE_TOPIC = 'mono_red_cropped'
NIR_IMAGE_TOPIC = 'mono_nir_cropped'
BLUE_IMAGE_TOPIC = 'mono_blue_cropped'

RED_FACE_IN_ROI_REGION_TOPIC = 'mono_red_roi'

MSMT_TOPIC = 'full_heart_rate'
DATA_TOPIC = 'full_data_heart_rate'
TRACKING_STATUS_TOPIC = 'mono_red_tracking_status'
HELPER_TIMER_PERIOD_SEC = 1
FULL_MSMT_PERIOD_SEC = 10
OK_FRAC_MSMT = 0.7
MAX_DROPOUT_BEFORE_RESET_SEC = 0.5
# Buffer about 3 seconds of cropped frames.
IMG_QUEUE_SIZE = 3 * 35
IMG_BUF_SIZE = IMG_QUEUE_SIZE * 1000 * 1000

NUM_SUBREGIONS_X = 10
NUM_SUBREGIONS_Y = 5

NUM_PLOT_X = NUM_SUBREGIONS_X
NUM_PLOT_Y = NUM_SUBREGIONS_Y

# Minimum of 30 beats per minute.
MIN_HEART_HZ = 30.0 / 60.0
# Maximum of 120 beats per minute.
MAX_HEART_HZ = 120.0 / 60.0

class HeartRate(object):
    def image_callback(self, red_image_data, nir_image_data, blue_image_data):
        with self.lock:
            chans = ((red_image_data, 'red'),
                     (nir_image_data, 'nir'),
                     (blue_image_data, 'blue'))

            for image_data, txt in chans:
                t = image_data.header.stamp.to_sec()

                if self.tlast[txt] is None:
                    self.tlast[txt] = t
                    return

                # Detect backward jumps in time in replay.
                if self.tlast[txt] > t:
                    self.clear_msmt_state()
                    self.tlast[txt] = t
                    rospy.logwarn('{} {}: Backward jump in time {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, self.tlast[txt], t))
                    return

                # Detect skips in data.
                if t - self.tlast[txt] > MAX_DROPOUT_BEFORE_RESET_SEC:
                    rospy.logwarn_throttle(1, '{} {}: Dropped samples for {} sec'.format(
                        self.name, txt, t - self.tlast[txt]))
                    self.clear_msmt_state()
                    self.tlast[txt] = t
                    return

                if self.delta[txt] is None:
                    self.delta[txt] = t - self.tlast[txt]
                    return

                self.delta[txt] = self.delta_alpha * (t - self.tlast[txt]) + (1 - self.delta_alpha) * self.delta[txt]
                self.tlast[txt] = t
        # End locked region.

        red_image = self.bridge.imgmsg_to_cv2(red_image_data,
                                              desired_encoding='passthrough')
        nir_image = self.bridge.imgmsg_to_cv2(nir_image_data,
                                              desired_encoding='passthrough')
        blue_image = self.bridge.imgmsg_to_cv2(blue_image_data,
                                               desired_encoding='passthrough')

        t = red_image_data.header.stamp.to_sec()
        with self.lock:
            if self.start_msmt: self.ti = t
            self.start_msmt = False
            self.t_buffer.append(t)
            self.red_msmt_buffer.append(red_image)
            self.nir_msmt_buffer.append(nir_image)
            self.blue_msmt_buffer.append(blue_image)
            self.tf = t
        # End locked region.

    def tracking_status_callback(self, data):
        with self.lock:
            if not self.tracking_status or not data.data:
                # Clear the measurement buffer unless we are valid, staying valid.
                self.clear_msmt_state()
            self.tracking_status = data.data

    def msmt_helper_callback(self, event):
        with self.lock:
            if not self.tracking_status:
                rospy.logwarn_throttle(1, '{}: Invalid tracking status.'.format(self.name))
                self.clear_msmt_state()
                return

            delta = self.delta['red']

            ti = self.ti
            tf = self.tf
            t_data = list(self.t_buffer)
            roi_data = list(self.roi_buffer)
            red_data = list(self.red_msmt_buffer)
            nir_data = list(self.nir_msmt_buffer)
            blue_data = list(self.blue_msmt_buffer)
            do_it = ti is not None and tf is not None and tf - ti >= FULL_MSMT_PERIOD_SEC
            if do_it:
                self.clear_buffers()
        # End locked region.

        if do_it:
            msmt_n = len(red_data)
            rospy.loginfo('{}: starting computation; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
                self.name, msmt_n, ti, tf, (tf - ti) / msmt_n))
            # Spawn a thread to do the measurement.
            t = threading.Thread(target=self.msmt_callback, name='full_' + self.name,
                                 args=(event, ti, tf,
                                       red_data, nir_data, blue_data,
                                       t_data, roi_data, delta))
            t.start()

    def msmt_callback(self, event, ti, tf, red_data, nir_data, blue_data, t_data, roi_data, delta):
        msmt_n = len(red_data)

        if msmt_n != len(nir_data) or msmt_n != len(blue_data) or msmt_n != len(t_data):
            rospy.logerror('{}: mismatched channels {} {} {} {}'.format(self.name, msmt_n,
                                                                        len(nir_data),
                                                                        len(blue_data),
                                                                        len(t_data)))
            return

        if delta is None or delta < 1e-3 or msmt_n < OK_FRAC_MSMT * FULL_MSMT_PERIOD_SEC / delta:
            rospy.loginfo_throttle(1, '{}: not enough samples {}'.format(self.name, msmt_n))
            return

        if len(roi_data) == 0:
            rospy.loginfo_throttle(1, '{}: no ROI {}; ti: {:.1f}; tf: {:.1f}'.format(
                self.name, len(roi_data), ti, tf))
            return

        if DEBUG_SAVE_IMAGES or DEBUG_PLOT:
            output_img_dir = LOG_DIR + os.path.sep + str(int(ti)) + os.path.sep
            os.mkdir(output_img_dir)

        ri = 0
        patch_avg = np.zeros((msmt_n, NUM_SUBREGIONS_X * NUM_SUBREGIONS_Y, 3))
        ii = 0
        for red, nir, blue, t in zip(red_data, nir_data, blue_data, t_data):
            # Find the next ROI update from the detect / track routine.
            while ri < len(roi_data) - 1 and t >= roi_data[ri][0]:
                ri += 1

            # TODO - if t > t_roi + EPS, track the ROI in this frame

            hroi = roi_data[ri][4] - roi_data[ri][2]
            xmin = roi_data[ri][1]; ymin = roi_data[ri][2]
            xmax = roi_data[ri][3]; ymax = ymin + int(0.25 * hroi)

            xd = int(math.floor((xmax - xmin) / float(NUM_SUBREGIONS_X)))
            yd = int(math.floor((ymax - ymin) / float(NUM_SUBREGIONS_Y)))

            for chan, cc, txt in ((red, 0, 'red'), (nir, 1, 'nir'), (blue, 2, 'blue')):
                crop = chan[ymin:ymin + yd * NUM_SUBREGIONS_Y,
                            xmin:xmin + xd * NUM_SUBREGIONS_X]
                if DEBUG_IMAGE and ii == 0:
                    cv2.imshow(txt + ' ROI', crop)
                    cv2.waitKey(10)

                if DEBUG_SAVE_IMAGES:
                    cv2.imwrite(output_img_dir + txt + '_{:05d}.png'.format(ii), crop)

                patch_avg[ii, :, cc] = np.mean(crop.reshape((xd, yd, -1)), axis=(0,1))

            ii += 1

        if DEBUG_PLOT:
            for cc, txt in ((0, 'red'), (1, 'nir'), (2, 'blue')):
                for rr in range(len(self.data_axes[0])):
                    if rr > patch_avg.shape[1] - 1:
                        break

                    self.data_axes[2*cc][rr].cla()
                    self.data_axes[2*cc][rr].plot(patch_avg[:, rr, cc])

                    sp = np.fft.fft(patch_avg[:, rr, cc])
                    freq = np.fft.fftfreq(sp.shape[-1], d=delta)
                    # Find the range of real frequency bins that we are interested in.
                    fminind = int(MIN_HEART_HZ * msmt_n * delta) + 1
                    fmaxind = int(MAX_HEART_HZ * msmt_n * delta)
                    amp = np.abs(sp)[fminind:fmaxind]

                    self.data_axes[2*cc+1][rr].cla()
                    self.data_axes[2*cc+1][rr].plot(freq[fminind:fmaxind] * 60.0, amp)
                # End loop over regions.
                plt.figure(self.fig[2*cc].number)
                plt.savefig(output_img_dir + txt + '_data.png')
                plt.figure(self.fig[2*cc+1].number)
                plt.savefig(output_img_dir + txt + '_amp.png')
            # End loop over channels.
        # End if we are saving plots.

        beats = 0
        rospy.loginfo('{}: {:.1f} beats / min; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
            self.name, beats, msmt_n, ti, tf, (tf - ti) / msmt_n))

    def region_callback(self, data):
        if len(data.polygon.points) != 2:
            return

        xmin = int(data.polygon.points[0].x)
        ymin = int(data.polygon.points[0].y)
        xmax = int(data.polygon.points[1].x)
        ymax = int(data.polygon.points[1].y)
        if (xmax - xmin) <= 0 or (ymax - ymin) <= 0:
            return

        with self.lock:
            self.roi_buffer.append([data.header.stamp.to_sec(), xmin, ymin, xmax, ymax])

    def clear_buffers(self):
        # Measurement buffers
        self.t_buffer = []
        self.roi_buffer = []
        self.red_msmt_buffer = []
        self.nir_msmt_buffer = []
        self.blue_msmt_buffer = []

        self.start_msmt = True

    def clear_msmt_state(self):
        rospy.logwarn_throttle(1, '{}: Resetting'.format(self.name))

        # Tracking status
        self.tracking_status = False

        self.ti = None
        self.tf = None

        self.tlast = dict(red=None, nir=None, blue=None)
        self.delta = dict(red=None, nir=None, blue=None)

        self.clear_buffers()

    def __init__(self, name):
        self.name = name

        self.lock = threading.Lock()

        self.clear_msmt_state()

        # Software time delta calculation
        self.delta_alpha = 0.8

        self.bridge = CvBridge()

        self.fig = [None]*6
        self.data_axes = [None]*6
        if DEBUG_PLOT:
            for ii in range(6):
                self.fig[ii] = plt.figure(figsize=(17, 11))
                self.data_axes[ii] = [self.fig[ii].add_subplot(NUM_PLOT_Y, NUM_PLOT_X, i) for i in range(1, NUM_PLOT_X * NUM_PLOT_Y + 1)]

        self.msmt_pub = rospy.Publisher(MSMT_TOPIC, Float32, queue_size=10)
        self.data_pub = rospy.Publisher(DATA_TOPIC, Float32MultiArray, queue_size=10)

        self.red_image_sub = message_filters.Subscriber(RED_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.nir_image_sub = message_filters.Subscriber(NIR_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.blue_image_sub = message_filters.Subscriber(BLUE_IMAGE_TOPIC, Image,
                                                         queue_size=IMG_QUEUE_SIZE,
                                                         buff_size=IMG_BUF_SIZE)

        self.approx_image_sync = message_filters.ApproximateTimeSynchronizer([self.red_image_sub,
                                                                              self.nir_image_sub,
                                                                              self.blue_image_sub],
                                                                             200, 0.1)
        self.approx_image_sync.registerCallback(self.image_callback)

        self.region_sub = rospy.Subscriber(RED_FACE_IN_ROI_REGION_TOPIC, PolygonStamped,
                                           self.region_callback, queue_size=IMG_QUEUE_SIZE)

        self.tracking_status_sub = rospy.Subscriber(TRACKING_STATUS_TOPIC, Bool,
                                                    self.tracking_status_callback, queue_size=1)

        self.msmt_helper_timer = rospy.Timer(rospy.Duration(HELPER_TIMER_PERIOD_SEC),
                                             self.msmt_helper_callback)

if __name__ == '__main__':
    rospy.init_node('heart_rate')
    hr = HeartRate(rospy.get_name())
    rospy.spin()
