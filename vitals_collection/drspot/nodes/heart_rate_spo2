#!/usr/bin/env python

# Copyright 2020 Boston Dynamics Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

DEBUG_RATE_CUT = False
DEBUG_RATE_DIV = 2
DEBUG_PLOT = False
DEBUG_IMAGE = False
DEBUG_SAVE_IMAGES = False
DEBUG_SAVE_DATA = False
DEBUG_MKDIR = DEBUG_SAVE_IMAGES or DEBUG_PLOT or DEBUG_SAVE_DATA
if DEBUG_PLOT:
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
if DEBUG_MKDIR:
    LOG_DIR = '/log'
    import os

import numpy as np
from scipy import signal
import threading
import cv2
import math
import insightface

import rospy
import message_filters
from sensor_msgs.msg import Image
from geometry_msgs.msg import PolygonStamped
from std_msgs.msg import Float32MultiArray, Float32, Bool
from cv_bridge import CvBridge

from drspot.utils.tracking import ROITracker

# Inputs.
RED_IMAGE_TOPIC = 'mono_red_cropped'
RED_REGION_IN_IMAGE_TOPIC = 'mono_red_region'
NIR_IMAGE_TOPIC = 'mono_nir_cropped'
NIR_REGION_IN_IMAGE_TOPIC = 'mono_nir_region'
BLUE_IMAGE_TOPIC = 'mono_blue_cropped'
BLUE_REGION_IN_IMAGE_TOPIC = 'mono_blue_region'

TRACKING_STATUS_TOPIC = 'mono_red_tracking_status'

# Outputs.
MSMT_TOPIC = 'full_heart_rate'
DATA_TOPIC = 'full_data_heart_rate'

# Carotid
# SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH = -0.2
# SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN = 1.2
# SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT = 0.25
# NUM_SUBREGIONS_X = 6
# NUM_SUBREGIONS_Y = 5

# Forehead
SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH = 0.0
SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN = 0.0
SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT = 0.25
NUM_SUBREGIONS_X = 10
NUM_SUBREGIONS_Y = 5

HELPER_TIMER_PERIOD_SEC = 1
FULL_MSMT_PERIOD_SEC = 3
OK_FRAC_MSMT = 0.7
MAX_DROPOUT_BEFORE_RESET_SEC = 0.5
# Buffer about 3 seconds of cropped frames.
IMG_QUEUE_SIZE = 3 * 35
IMG_BUF_SIZE = IMG_QUEUE_SIZE * 1000 * 1000

T_EPS = 1e-4

DETECT_TRACK_SCALE_FACTOR = 0.5

FACE_DETECTION_LIKELIHOOD_THRESHOLD = 0.9
FACE_DETECTION_SCALE = 1.0
# Potentially use a more accurate tracker than the one in the multichrome_face_tracker node,
# and/or run on every frame, at the expense of more computation time.
CV_TRACKER_TYPE = 'TM_CCORR_NORMED'

NUM_PLOT_X = NUM_SUBREGIONS_X
NUM_PLOT_Y = NUM_SUBREGIONS_Y

# Minimum of 45 beats per minute.
MIN_HEART_HZ = 45.0 / 60.0
# Maximum of 220 beats per minute.
MAX_HEART_HZ = 220.0 / 60.0
# Minimum of 30 beats per minute in stored FFT.
MIN_HZ = 30.0 / 60.0
# Maximum of 440 beats per minute to look for the 2nd harmonic.
MAX_HZ = 2 * MAX_HEART_HZ

CHAN_IDX = (0, 1, 2)
CHAN_TXT = ('red', 'nir', 'blue')
CC = len(CHAN_IDX)

PBV_STATIC = np.array([ 0.68,  1.0,    0.70])
PBV_UPDATE = np.array([-0.014, 0.0024, 0.0013])

PBV_TO_CHECK = [100, 95, 90, 85, 80, 75, 70]

NUM_FIG = len(CHAN_IDX) + 2 * len(PBV_TO_CHECK)

def grad(im) :
    # Calculate the x and y gradients using Sobel operator
    grad_x = cv2.Sobel(im,cv2.CV_32F,1,0,ksize=3)
    grad_y = cv2.Sobel(im,cv2.CV_32F,0,1,ksize=3)

    # Combine the two gradients
    grad = cv2.addWeighted(np.absolute(grad_x), 0.5, np.absolute(grad_y), 0.5, 0)
    return grad

def butter_bandpass(lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = signal.butter(order, [low, high], btype='band')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5, axis=-1):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = signal.lfilter(b, a, data, axis=axis)
    return y

if DEBUG_RATE_CUT:
    _TMP_ = None

class HeartRate(object):
    def image_callback(self, red_image_data, nir_image_data, blue_image_data,
                       red_region, nir_region, blue_region):
        if DEBUG_RATE_CUT:
            global _TMP_
            if _TMP_ is None: _TMP_ = 0
            _TMP_ += 1
            if _TMP_ == DEBUG_RATE_DIV:
                _TMP_ = 0
            else:
                return
        with self.lock:
            chans = zip((red_image_data, nir_image_data, blue_image_data),
                        (red_region, nir_region, blue_region),
                        CHAN_TXT)

            for image_data, region, txt in chans:
                t = image_data.header.stamp.to_sec()

                if self.tlast[txt] is None:
                    self.tlast[txt] = t
                    return

                # Detect backward jumps in time in replay.
                if self.tlast[txt] > t + T_EPS:
                    #self.clear_msmt_state()
                    self.tlast[txt] = t
                    rospy.logwarn_throttle(1, '{} {}: Backward jump in time {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, self.tlast[txt], t))
                    #return

                # Detect duplicate timestamps due to message synchronization.
                if self.tlast[txt] >= t:
                    rospy.logwarn('{} {}: Duplicate timestamp {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, self.tlast[txt], t))

                # Detect skips in data.
                if t - self.tlast[txt] > MAX_DROPOUT_BEFORE_RESET_SEC:
                    rospy.logwarn_throttle(1, '{} {}: Dropped samples for {} sec'.format(
                        self.name, txt, t - self.tlast[txt]))
                    self.clear_msmt_state()
                    self.tlast[txt] = t
                    return

                # Detect region message header mismatch with image header.
                region_t = region.header.stamp.to_sec()
                if abs(t - region_t) > T_EPS:
                    #self.clear_msmt_state()
                    self.tlast[txt] = t
                    rospy.logwarn_throttle(1, '{} {}: Region out of sync with image {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, region_t, t))
                    #return

                if self.delta[txt] is None:
                    self.delta[txt] = t - self.tlast[txt]
                    return

                self.delta[txt] = self.delta_alpha * (t - self.tlast[txt]) + (1 - self.delta_alpha) * self.delta[txt]
                self.tlast[txt] = t
        # End locked region.

        red_image = self.bridge.imgmsg_to_cv2(red_image_data,
                                              desired_encoding='passthrough')
        nir_image = self.bridge.imgmsg_to_cv2(nir_image_data,
                                              desired_encoding='passthrough')
        blue_image = self.bridge.imgmsg_to_cv2(blue_image_data,
                                               desired_encoding='passthrough')

        t = red_image_data.header.stamp.to_sec()
        with self.lock:
            if self.start_msmt: self.ti = t
            self.start_msmt = False
            self.t_buffer.append(t)
            self.red_msmt_buffer.append(red_image)
            self.nir_msmt_buffer.append(nir_image)
            self.blue_msmt_buffer.append(blue_image)
            self.red_offset_buffer.append(np.array([red_region.polygon.points[0].x,
                                                    red_region.polygon.points[0].y]))
            self.nir_offset_buffer.append(np.array([nir_region.polygon.points[0].x,
                                                    nir_region.polygon.points[0].y]))
            self.blue_offset_buffer.append(np.array([blue_region.polygon.points[0].x,
                                                     blue_region.polygon.points[0].y]))
            self.tf = t
        # End locked region.

    def tracking_status_callback(self, data):
        with self.lock:
            if not self.tracking_status or not data.data:
                # Clear the measurement buffer unless we are valid, staying valid.
                self.clear_msmt_state()
            self.tracking_status = data.data

    def msmt_helper_callback(self, event):
        with self.lock:
            if not self.tracking_status:
                rospy.logwarn_throttle(1, '{}: Invalid tracking status.'.format(self.name))
                self.clear_msmt_state()
                return

            delta = self.delta['red']

            ti = self.ti
            tf = self.tf
            t_data = list(self.t_buffer)
            red_data = list(self.red_msmt_buffer)
            nir_data = list(self.nir_msmt_buffer)
            blue_data = list(self.blue_msmt_buffer)
            red_offset = list(self.red_offset_buffer)
            nir_offset = list(self.nir_offset_buffer)
            blue_offset = list(self.blue_offset_buffer)
            do_it = ti is not None and tf is not None and tf - ti >= FULL_MSMT_PERIOD_SEC
            if do_it:
                self.clear_buffers()
        # End locked region.

        if do_it:
            msmt_n = len(red_data)
            rospy.loginfo('{}: starting computation; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
                self.name, msmt_n, ti, tf, (tf - ti) / msmt_n))
            # Spawn a thread to do the measurement.
            t = threading.Thread(target=self.msmt_callback, name='full_' + self.name,
                                 args=(event, ti, tf,
                                       red_data, nir_data, blue_data,
                                       red_offset, nir_offset, blue_offset,
                                       t_data, delta))
            t.start()

    def msmt_callback(self, event, ti, tf,
                      red_data, nir_data, blue_data,
                      red_offset, nir_offset, blue_offset,
                      t_data, delta):
        msmt_n = len(red_data)

        if delta is None or delta < 1e-3 or msmt_n == 0 or msmt_n < OK_FRAC_MSMT * FULL_MSMT_PERIOD_SEC / delta:
            rospy.loginfo_throttle(1, '{}: not enough samples {}'.format(self.name, msmt_n))
            return

        if DEBUG_MKDIR:
            output_dir = LOG_DIR + os.path.sep + str(int(ti)) + os.path.sep
            os.mkdir(output_dir)
            if DEBUG_SAVE_IMAGES:
                output_img_dir = output_dir + 'img' + os.path.sep
                os.mkdir(output_img_dir)

        ri = 0 # ROI index over time.
        patch_avg = np.zeros((msmt_n, NUM_SUBREGIONS_X * NUM_SUBREGIONS_Y, 3))
        ii = 0 # Index into synchronized channels.
        # Initialize a tracker on the sub-roi. Use a more accurate tracker than the one in
        # the multichrome_face_tracker node and/or track on every frame at the expense of more
        # computation time.
        red_tracker = ROITracker(CV_TRACKER_TYPE)
        nir_tracker = ROITracker(CV_TRACKER_TYPE)
        blue_tracker = ROITracker(CV_TRACKER_TYPE)
        red_last_loc = np.array([0, 0])
        nir_last_loc = np.array([0, 0])
        blue_last_loc = np.array([0, 0])
        detector = insightface.model_zoo.get_model('retinaface_r50_v1')
        detector.prepare(ctx_id=-1, nms=0.4)
        for red, nir, blue, red_off, nir_off, blue_off, t in zip(red_data,
                                                                 nir_data,
                                                                 blue_data,
                                                                 red_offset,
                                                                 nir_offset,
                                                                 blue_offset,
                                                                 t_data):
            for chan, off, last_loc, tracker, cc, txt in zip((red, nir, blue),
                                                             (red_off,
                                                              nir_off,
                                                              blue_off),
                                                             (red_last_loc,
                                                              nir_last_loc,
                                                              blue_last_loc),
                                                             (red_tracker,
                                                              nir_tracker,
                                                              blue_tracker),
                                                             CHAN_IDX, CHAN_TXT):
                (rows, cols) = chan.shape
                r = int(rows * DETECT_TRACK_SCALE_FACTOR)
                c = int(cols * DETECT_TRACK_SCALE_FACTOR)
                resize = cv2.resize(chan, (c, r), interpolation=cv2.INTER_AREA)
                if ii == 0:
                    chan3 = cv2.cvtColor(resize, cv2.COLOR_GRAY2RGB)
                    bboxes, landmarks = detector.detect(chan3,
                                                        threshold=FACE_DETECTION_LIKELIHOOD_THRESHOLD,
                                                        scale=FACE_DETECTION_SCALE)
                    if DEBUG_MKDIR:
                        # All overlays have colors below in case we use an RGB image in the future.
                        for box in bboxes.astype(int):
                            x, y, x2, y2 = box[0:4]
                            # Draw a rectangle for each face bounding box.
                            cv2.rectangle(resize, (x, y), (x2, y2), (255,255,255), 2)
                        for face in landmarks.astype(int):
                            for point in face:
                                x, y = point
                                # Draw a circle at each landmark.
                                cv2.circle(resize, (x, y), 5, (255,255,255), 1)
                        cv2.imwrite(output_dir + txt + '_debug_det.png', resize)
                    if len(bboxes) != 1:
                        rospy.logwarn_throttle(1, '{} {}: {} faces detected in {}:{}; erroring'.format(
                            self.name, txt, len(bboxes), ti, tf))
                        return
                    wface = bboxes[0][2] - bboxes[0][0]
                    hface = bboxes[0][3] - bboxes[0][1]
                    bboxes[0][0] -= SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH * wface
                    bboxes[0][1] += SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN * hface
                    bboxes[0][2] += SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH * wface
                    bboxes[0][3] = bboxes[0][1] + SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT * hface
                    try:
                        last_loc[:] = bboxes[0][0:2] + off * DETECT_TRACK_SCALE_FACTOR
                        tracker.start_track(resize, bboxes[0])
                    except Exception as e:
                        rospy.logwarn_throttle(1, '{} {}: failed track init in {}:{}; {} = {}'.format(
                            self.name, txt, ti, tf, bboxes[0], e))
                        return
                else:
                    expected_in_region = last_loc - off * DETECT_TRACK_SCALE_FACTOR
                    tracker.update(resize, expected_in_region)
                    bboxes = np.array([tracker.bbox])
                    last_loc[:] = bboxes[0][0:2] + off * DETECT_TRACK_SCALE_FACTOR

                xmin, ymin, xmax, ymax = tuple((bboxes[0][0:4] / DETECT_TRACK_SCALE_FACTOR).astype(int))
                if xmin < 0: xmin = 0
                if ymin < 0: ymin = 0
                if xmax >= cols: xmax = cols-1
                if ymax >= rows: ymax = rows-1

                xd = int(math.floor((xmax - xmin) / float(NUM_SUBREGIONS_X)))
                yd = int(math.floor((ymax - ymin) / float(NUM_SUBREGIONS_Y)))

                crop = chan[ymin:ymin + yd * NUM_SUBREGIONS_Y,
                            xmin:xmin + xd * NUM_SUBREGIONS_X]
                if DEBUG_IMAGE and ii == 0:
                    cv2.imshow(txt + ' ROI', crop)
                    cv2.waitKey(10)

                if DEBUG_SAVE_IMAGES:
                    try:
                        cv_image = chan.copy()
                        # Draw vertical lines (constant x coordinate).
                        for xline in range(xmin, xmax, xd):
                            cv2.line(cv_image, (xline, ymin), (xline, ymax), (255,255,255), 3)
                        # Draw vertical lines (constant y coordinate).
                        for yline in range(ymin, ymax, yd):
                            cv2.line(cv_image, (xmin, yline), (xmax, yline), (255,255,255), 3)
                        cv2.imwrite(output_img_dir + txt + '_{:05d}.png'.format(ii), cv_image)
                    except Exception as e:
                        print(e)
                        pass

                # Spatial average over each subregion at this point in time.
                try:
                    patch_avg[ii, :, cc] = np.mean(crop.reshape((xd, yd, -1)),
                                                   axis=(0,1))
                except Exception as e:
                    rospy.logwarn_throttle(1, '{} {}: failed spatial average in '
                                           + '{}:{} idx {}; {} {} {} {} {} {} {} {} = {}'.format(
                        self.name, txt, ti, tf, ii, crop.shape, chan.shape, xd, yd, xmin, ymin, xmax, ymax, e))
                    return
            # End loop over colors.
            ii += 1
        # End loop through data series.

        patch_avg /= np.mean(patch_avg, axis=0)
        patch_avg -= 1.0
        #patch_avg = signal.detrend(patch_avg, axis=0)

        patch_filt = butter_bandpass_filter(patch_avg, MIN_HZ, MAX_HZ,
                                            1.0 / delta,
                                            axis=0)
        patch_pulse = np.zeros((patch_avg.shape[0], patch_avg.shape[1], len(PBV_TO_CHECK)))

        # Find the range of real frequency bins that we are interested in.
        fminind = int(MIN_HZ * msmt_n * delta)
        fmaxind = int(MAX_HZ * msmt_n * delta)
        hr_fminind = int(MIN_HEART_HZ * msmt_n * delta) - fminind
        hr_fmaxind = int(MAX_HEART_HZ * msmt_n * delta) - fminind
        fminind += 1
        hr_fminind += 1
        patch_freq = np.zeros((fmaxind-fminind+1, patch_avg.shape[1], len(PBV_TO_CHECK)))
        peak_freq_count = np.zeros(patch_freq.shape[0])
        peak_freq = np.zeros((patch_avg.shape[1], len(PBV_TO_CHECK)))
        freq = None

        for rr in range(patch_avg.shape[1]):
            c_n = patch_filt[:, rr, :].reshape((-1,3)).T
            q_inv = np.linalg.inv(np.matmul(c_n, c_n.T))
            for ss in range(len(PBV_TO_CHECK)):
                spo2 = PBV_TO_CHECK[ss]
                w_pbv = np.matmul(PBV_STATIC + (100.0 - spo2) * PBV_UPDATE,
                                  q_inv)
                w_pbv /= np.linalg.norm(w_pbv)
                patch_pulse[:, rr, ss] = np.matmul(w_pbv, c_n)

                sp = np.fft.fft(patch_pulse[:, rr, ss])
                if freq is None:
                    freq = np.fft.fftfreq(sp.shape[-1], d=delta)[fminind:fmaxind+1]
                patch_freq[:, rr, ss] = np.abs(sp)[fminind:fmaxind+1]
                freq_idx = patch_freq[hr_fminind:hr_fmaxind, rr, ss].argmax() + hr_fminind
                peak_freq[rr, ss] = freq[freq_idx]
                peak_freq_count[freq_idx] += 1

            if DEBUG_SAVE_DATA:
                np.savetxt(output_dir + 'raw_{:03d}.csv'.format(rr),
                           patch_avg[:, rr, :].reshape((-1,CC)),
                           delimiter=',')
                np.savetxt(output_dir + 'filt_{:03d}.csv'.format(rr),
                           patch_filt[:, rr, :].reshape((-1,CC)),
                           delimiter=',')
                np.savetxt(output_dir + 'pulse_{:03d}.csv'.format(rr),
                           patch_pulse[:, rr, :].reshape((-1, patch_pulse.shape[2])),
                           delimiter=',')
                np.savetxt(output_dir + 'freq_{:03d}.csv'.format(rr),
                           patch_freq[:, rr, :].reshape((-1, patch_freq.shape[2])),
                           delimiter=',')

        if DEBUG_PLOT:
            fig = [None]*NUM_FIG
            data_axes = [None]*NUM_FIG
            for ii in range(NUM_FIG):
                fig[ii] = plt.figure(figsize=(NUM_PLOT_X * 20,
                                              NUM_PLOT_Y * 20))
                data_axes[ii] = [fig[ii].add_subplot(NUM_PLOT_Y, NUM_PLOT_X, i) for i in range(1, NUM_PLOT_X * NUM_PLOT_Y + 1)]
            for rr in range(len(data_axes[0])):
                if rr > patch_avg.shape[1] - 1:
                    break

                for ss in range(len(PBV_TO_CHECK)):
                    data_axes[CC+2*ss][rr].plot(patch_pulse[:, rr, ss])

                    data_axes[CC+2*ss+1][rr].plot(freq * 60.0, patch_freq[:, rr, ss])
                    data_axes[CC+2*ss+1][rr].set_xticks(np.arange(freq[0] * 60.0,
                                                                  freq[-1] * 60.0,
                                                                  10.0))
                    data_axes[CC+2*ss+1][rr].grid()

                for cc in CHAN_IDX:
                    data_axes[cc][rr].plot(patch_filt[:, rr, cc])
                # End loop over channels.
            # End loop over regions.
            for cc, txt in zip(CHAN_IDX, CHAN_TXT):
                plt.figure(fig[cc].number)
                try:
                    plt.savefig(output_dir + txt + '_data.png')
                except:
                    pass
                finally:
                    plt.close(fig[cc])

            for ss in range(len(PBV_TO_CHECK)):
                plt.figure(fig[CC+2*ss].number)
                try:
                    plt.savefig(output_dir + 'pulse_spo2_{}.png'.format(PBV_TO_CHECK[ss]))
                except:
                    pass
                finally:
                    plt.close(fig[CC+2*ss])
                plt.figure(fig[CC+2*ss+1].number)
                try:
                    plt.savefig(output_dir + 'freq_spo2_{}.png'.format(PBV_TO_CHECK[ss]))
                except:
                    pass
                finally:
                    plt.close(fig[CC+2*ss+1])
        # End if we are saving plots.

        beats = freq[peak_freq_count.argmax()] * 60.0
        rospy.loginfo('{}: {:.1f} beats / min; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
            self.name, beats, msmt_n, ti, tf, (tf - ti) / msmt_n))

    def clear_buffers(self):
        # Measurement buffers
        self.t_buffer = []
        self.red_msmt_buffer = []
        self.nir_msmt_buffer = []
        self.blue_msmt_buffer = []
        self.red_offset_buffer = []
        self.nir_offset_buffer = []
        self.blue_offset_buffer = []

        self.start_msmt = True

    def clear_msmt_state(self):
        rospy.logwarn_throttle(1, '{}: Resetting'.format(self.name))

        # Tracking status
        self.tracking_status = False

        self.ti = None
        self.tf = None

        self.tlast = dict(red=None, nir=None, blue=None)
        self.delta = dict(red=None, nir=None, blue=None)

        self.clear_buffers()

    def __init__(self, name):
        self.name = name

        self.lock = threading.Lock()

        self.clear_msmt_state()

        # Software time delta calculation
        self.delta_alpha = 0.8

        self.bridge = CvBridge()

        self.msmt_pub = rospy.Publisher(MSMT_TOPIC, Float32, queue_size=10)
        self.data_pub = rospy.Publisher(DATA_TOPIC, Float32MultiArray, queue_size=10)

        self.red_image_sub = message_filters.Subscriber(RED_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.red_region_sub = message_filters.Subscriber(RED_REGION_IN_IMAGE_TOPIC,
                                                         PolygonStamped,
                                                         queue_size=IMG_QUEUE_SIZE)

        self.nir_image_sub = message_filters.Subscriber(NIR_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.nir_region_sub = message_filters.Subscriber(NIR_REGION_IN_IMAGE_TOPIC,
                                                         PolygonStamped,
                                                         queue_size=IMG_QUEUE_SIZE)

        self.blue_image_sub = message_filters.Subscriber(BLUE_IMAGE_TOPIC, Image,
                                                         queue_size=IMG_QUEUE_SIZE,
                                                         buff_size=IMG_BUF_SIZE)
        self.blue_region_sub = message_filters.Subscriber(BLUE_REGION_IN_IMAGE_TOPIC,
                                                          PolygonStamped,
                                                          queue_size=IMG_QUEUE_SIZE)

        self.approx_image_sync = message_filters.ApproximateTimeSynchronizer([self.red_image_sub,
                                                                              self.nir_image_sub,
                                                                              self.blue_image_sub,
                                                                              self.red_region_sub,
                                                                              self.nir_region_sub,
                                                                              self.blue_region_sub],
                                                                             200, 0.1)
        self.approx_image_sync.registerCallback(self.image_callback)

        self.tracking_status_sub = rospy.Subscriber(TRACKING_STATUS_TOPIC, Bool,
                                                    self.tracking_status_callback, queue_size=1)

        self.msmt_helper_timer = rospy.Timer(rospy.Duration(HELPER_TIMER_PERIOD_SEC),
                                             self.msmt_helper_callback)

if __name__ == '__main__':
    rospy.init_node('heart_rate')
    hr = HeartRate(rospy.get_name())
    rospy.spin()
