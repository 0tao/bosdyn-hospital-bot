#!/usr/bin/env python

# Copyright 2020 Boston Dynamics Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

DEBUG_PLOT = False
DEBUG_IMAGE = False
DEBUG_SAVE_IMAGES = False
DEBUG_SAVE_DATA = False
DEBUG_MKDIR = DEBUG_SAVE_IMAGES or DEBUG_PLOT or DEBUG_SAVE_DATA
if DEBUG_PLOT:
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
if DEBUG_MKDIR:
    LOG_DIR = '/log'
    import os
import time

import numpy as np
from scipy import signal
import threading
import cv2
import math

import rospy
import message_filters
from sensor_msgs.msg import Image
from geometry_msgs.msg import PolygonStamped
from std_msgs.msg import Float32MultiArray, Float32, Bool
from cv_bridge import CvBridge

from drspot.utils.tracking import ROITracker

# Inputs.
RED_IMAGE_TOPIC = 'mono_red_cropped'
NIR_IMAGE_TOPIC = 'mono_nir_cropped'
BLUE_IMAGE_TOPIC = 'mono_blue_cropped'
RED_FACE_IN_ROI_REGION_TOPIC = 'mono_red_roi'
TRACKING_STATUS_TOPIC = 'mono_red_tracking_status'

# Outputs.
MSMT_TOPIC = 'full_heart_rate'
DATA_TOPIC = 'full_data_heart_rate'

# Carotid
#SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH = 0.1
#SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN = 1.15
#SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT = 0.5

# Forehead
SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH = 0.0
SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN = 0.0
SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT = 0.25

HELPER_TIMER_PERIOD_SEC = 1
FULL_MSMT_PERIOD_SEC = 10
OK_FRAC_MSMT = 0.7
MAX_DROPOUT_BEFORE_RESET_SEC = 0.5
# Buffer about 3 seconds of cropped frames.
IMG_QUEUE_SIZE = 3 * 35
IMG_BUF_SIZE = IMG_QUEUE_SIZE * 1000 * 1000

T_EPS = 1e-4

# Potentially use a more accurate tracker than the one in the multichrome_face_tracker node,
# and/or run on every frame, at the expense of more computation time.
CV_TRACKER_TYPE = 'CSRT' #'MEDIANFLOW'

NUM_SUBREGIONS_X = 20
NUM_SUBREGIONS_Y = 10

NUM_PLOT_X = NUM_SUBREGIONS_X
NUM_PLOT_Y = NUM_SUBREGIONS_Y

# Minimum of 30 beats per minute.
MIN_HEART_HZ = 30.0 / 60.0
# Maximum of 300 beats per minute to look for the 2nd harmonic.
MAX_HEART_HZ = 300.0 / 60.0

CHAN_IDX = (0, 1, 2)
CHAN_TXT = ('red', 'nir', 'blue')
CC = len(CHAN_IDX)

PBV_STATIC = np.array([ 0.68,  1.0,    0.70])
PBV_UPDATE = np.array([-0.014, 0.0024, 0.0013])

PBV_TO_CHECK = [100, 95, 90, 85, 80, 75, 70]

NUM_FIG = len(CHAN_IDX) + 2 * len(PBV_TO_CHECK)

def butter_bandpass(lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = signal.butter(order, [low, high], btype='band')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5, axis=-1):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = signal.lfilter(b, a, data, axis=axis)
    return y

class HeartRate(object):
    def image_callback(self, red_image_data, nir_image_data, blue_image_data):
        with self.lock:
            chans = zip((red_image_data, nir_image_data, blue_image_data),
                        CHAN_TXT)

            for image_data, txt in chans:
                t = image_data.header.stamp.to_sec()

                if self.tlast[txt] is None:
                    self.tlast[txt] = t
                    return

                # Detect backward jumps in time in replay.
                if self.tlast[txt] > t + T_EPS:
                    self.clear_msmt_state()
                    self.tlast[txt] = t
                    rospy.logwarn_throttle(1, '{} {}: Backward jump in time {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, self.tlast[txt], t))
                    return

                # Detect duplicate timestamps due to message synchronization.
                if self.tlast[txt] >= t:
                    rospy.logwarn('{} {}: Duplicate timestamp {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, self.tlast[txt], t))

                # Detect skips in data.
                if t - self.tlast[txt] > MAX_DROPOUT_BEFORE_RESET_SEC:
                    rospy.logwarn_throttle(1, '{} {}: Dropped samples for {} sec'.format(
                        self.name, txt, t - self.tlast[txt]))
                    self.clear_msmt_state()
                    self.tlast[txt] = t
                    return

                if self.delta[txt] is None:
                    self.delta[txt] = t - self.tlast[txt]
                    return

                self.delta[txt] = self.delta_alpha * (t - self.tlast[txt]) + (1 - self.delta_alpha) * self.delta[txt]
                self.tlast[txt] = t
        # End locked region.

        red_image = self.bridge.imgmsg_to_cv2(red_image_data,
                                              desired_encoding='passthrough')
        nir_image = self.bridge.imgmsg_to_cv2(nir_image_data,
                                              desired_encoding='passthrough')
        blue_image = self.bridge.imgmsg_to_cv2(blue_image_data,
                                               desired_encoding='passthrough')

        t = red_image_data.header.stamp.to_sec()
        with self.lock:
            if self.start_msmt: self.ti = t
            self.start_msmt = False
            self.t_buffer.append(t)
            self.red_msmt_buffer.append(red_image)
            self.nir_msmt_buffer.append(nir_image)
            self.blue_msmt_buffer.append(blue_image)
            self.tf = t
        # End locked region.

    def tracking_status_callback(self, data):
        with self.lock:
            if not self.tracking_status or not data.data:
                # Clear the measurement buffer unless we are valid, staying valid.
                self.clear_msmt_state()
            self.tracking_status = data.data

    def msmt_helper_callback(self, event):
        with self.lock:
            if not self.tracking_status:
                rospy.logwarn_throttle(1, '{}: Invalid tracking status.'.format(self.name))
                self.clear_msmt_state()
                return

            delta = self.delta['red']

            ti = self.ti
            tf = self.tf
            t_data = list(self.t_buffer)
            roi_data = list(self.roi_buffer)
            red_data = list(self.red_msmt_buffer)
            nir_data = list(self.nir_msmt_buffer)
            blue_data = list(self.blue_msmt_buffer)
            do_it = ti is not None and tf is not None and tf - ti >= FULL_MSMT_PERIOD_SEC
            if do_it:
                self.clear_buffers()
        # End locked region.

        if do_it:
            msmt_n = len(red_data)
            rospy.loginfo('{}: starting computation; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
                self.name, msmt_n, ti, tf, (tf - ti) / msmt_n))
            # Spawn a thread to do the measurement.
            t = threading.Thread(target=self.msmt_callback, name='full_' + self.name,
                                 args=(event, ti, tf,
                                       red_data, nir_data, blue_data,
                                       t_data, roi_data, delta))
            t.start()

    def msmt_callback(self, event, ti, tf, red_data, nir_data, blue_data, t_data, roi_data, delta):
        msmt_n = len(red_data)

        if msmt_n != len(nir_data) or msmt_n != len(blue_data) or msmt_n != len(t_data):
            rospy.logerror('{}: mismatched channels {} {} {} {}'.format(self.name, msmt_n,
                                                                        len(nir_data),
                                                                        len(blue_data),
                                                                        len(t_data)))
            return

        if delta is None or delta < 1e-3 or msmt_n == 0 or msmt_n < OK_FRAC_MSMT * FULL_MSMT_PERIOD_SEC / delta:
            rospy.loginfo_throttle(1, '{}: not enough samples {}'.format(self.name, msmt_n))
            return

        if len(roi_data) == 0:
            rospy.loginfo_throttle(1, '{}: no ROI {}; ti: {:.1f}; tf: {:.1f}'.format(
                self.name, len(roi_data), ti, tf))
            return

        if DEBUG_MKDIR:
            output_img_dir = LOG_DIR + os.path.sep + str(int(ti)) + os.path.sep
            os.mkdir(output_img_dir)

        ri = 0 # ROI index over time.
        patch_avg = np.zeros((msmt_n, NUM_SUBREGIONS_X * NUM_SUBREGIONS_Y, 3))
        ii = 0 # Index into synchronized channels.
        # Initialize a tracker on the sub-roi. Use a more accurate tracker than the one in
        # the multichrome_face_tracker node and/or track on every frame at the expense of more
        # computation time.
        wroi = roi_data[ri][3] - roi_data[ri][1]
        hroi = roi_data[ri][4] - roi_data[ri][2]
        xmin = roi_data[ri][1] - int(SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH * wroi)
        ymin = roi_data[ri][2] + int(SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT_DOWN * hroi)
        xmax = roi_data[ri][3] + int(SUBROI_EXTRA_HALF_WIDTH_FRAC_OF_FACE_WIDTH * wroi)
        ymax = ymin + int(SUBROI_HEIGHT_FRAC_OF_FACE_HEIGHT * hroi)
        red_tracker = ROITracker(CV_TRACKER_TYPE)
        nir_tracker = ROITracker(CV_TRACKER_TYPE)
        blue_tracker = ROITracker(CV_TRACKER_TYPE)
        for red, nir, blue, t in zip(red_data, nir_data, blue_data, t_data):
            # TODO - how to use this information?
            # Find the next ROI update from the detect / track routine.
            #while ri < len(roi_data) - 1 and t >= roi_data[ri][0]:
            #    ri += 1

            for chan, tracker, cc, txt in zip((red, nir, blue),
                                              (red_tracker,
                                               nir_tracker,
                                               blue_tracker),
                                              CHAN_IDX, CHAN_TXT):
                if ii == 0:
                    # TODO - Make sure ROIs match across channels.
                    tracker.start_track(chan, [xmin, ymin, xmax, ymax])
                else:
                    tracker.update(chan)
                    xmin = int(tracker.bbox[0]); ymin = int(tracker.bbox[1])
                    xmax = int(tracker.bbox[2]); ymax = int(tracker.bbox[3])

                xd = int(math.floor((xmax - xmin) / float(NUM_SUBREGIONS_X)))
                yd = int(math.floor((ymax - ymin) / float(NUM_SUBREGIONS_Y)))

                crop = chan[ymin:ymin + yd * NUM_SUBREGIONS_Y,
                            xmin:xmin + xd * NUM_SUBREGIONS_X]
                if DEBUG_IMAGE and ii == 0:
                    cv2.imshow(txt + ' ROI', crop)
                    cv2.waitKey(10)

                if DEBUG_SAVE_IMAGES:
                    try:
                        cv2.imwrite(output_img_dir + txt + '_{:05d}.png'.format(ii), crop)
                    except:
                        pass

                # Spatial average over each subregion at this point in time.
                patch_avg[ii, :, cc] = np.mean(crop.reshape((xd, yd, -1)), axis=(0,1))
            # End loop over colors.
            ii += 1
        # End loop through data series.

        patch_avg /= np.mean(patch_avg, axis=0)
        patch_avg -= 1.0
        #patch_avg = signal.detrend(patch_avg, axis=0)

        patch_filt = butter_bandpass_filter(patch_avg,
                                            MIN_HEART_HZ, MAX_HEART_HZ,
                                            1.0 / delta,
                                            axis=0)
        patch_pulse = np.zeros((patch_avg.shape[0], patch_avg.shape[1], len(PBV_TO_CHECK)))

        # Find the range of real frequency bins that we are interested in.
        fminind = int(MIN_HEART_HZ * msmt_n * delta) + 1
        fmaxind = int(MAX_HEART_HZ * msmt_n * delta)
        patch_freq = np.zeros((fmaxind-fminind+1, patch_avg.shape[1], len(PBV_TO_CHECK)))
        peak_freq_count = np.zeros(patch_freq.shape[0])
        peak_freq = np.zeros((patch_avg.shape[1], len(PBV_TO_CHECK)))
        freq = None

        for rr in range(patch_avg.shape[1]):
            c_n = patch_filt[:, rr, :].reshape((-1,3)).T
            q_inv = np.linalg.inv(np.matmul(c_n, c_n.T))
            for ss in range(len(PBV_TO_CHECK)):
                spo2 = PBV_TO_CHECK[ss]
                w_pbv = np.matmul(PBV_STATIC + (100.0 - spo2) * PBV_UPDATE,
                                  q_inv)
                w_pbv /= np.linalg.norm(w_pbv)
                patch_pulse[:, rr, ss] = np.matmul(w_pbv, c_n)

                sp = np.fft.fft(patch_pulse[:, rr, ss])
                if freq is None:
                    freq = np.fft.fftfreq(sp.shape[-1], d=delta)[fminind:fmaxind+1]
                patch_freq[:, rr, ss] = np.abs(sp)[fminind:fmaxind+1]
                freq_idx = patch_freq[:, rr, ss].argmax()
                peak_freq[rr, ss] = freq[freq_idx]
                peak_freq_count[freq_idx] += 1

            if DEBUG_SAVE_DATA:
                np.savetxt(output_img_dir + 'raw_{:03d}.csv'.format(rr),
                           patch_avg[:, rr, :].reshape((-1,3)),
                           delimiter=',')
                np.savetxt(output_img_dir + 'filt_{:03d}.csv'.format(rr),
                           patch_filt[:, rr, :].reshape((-1,3)),
                           delimiter=',')
                np.savetxt(output_img_dir + 'pulse_{:03d}.csv'.format(rr),
                           patch_pulse[:, rr, :].reshape((-1, patch_pulse.shape[2])),
                           delimiter=',')

        if DEBUG_PLOT:
            fig = [None]*NUM_FIG
            data_axes = [None]*NUM_FIG
            for ii in range(NUM_FIG):
                fig[ii] = plt.figure(figsize=(30, 30))
                data_axes[ii] = [fig[ii].add_subplot(NUM_PLOT_Y, NUM_PLOT_X, i) for i in range(1, NUM_PLOT_X * NUM_PLOT_Y + 1)]
            for rr in range(len(data_axes[0])):
                if rr > patch_avg.shape[1] - 1:
                    break

                for ss in range(len(PBV_TO_CHECK)):
                    data_axes[CC+2*ss][rr].plot(patch_pulse[:, rr, ss])
                    data_axes[CC+2*ss+1][rr].plot(freq * 60.0, patch_freq[:, rr, ss])

                for cc in CHAN_IDX:
                    data_axes[cc][rr].plot(patch_filt[:, rr, cc])
                # End loop over channels.
            # End loop over regions.
            for cc, txt in zip(CHAN_IDX, CHAN_TXT):
                plt.figure(fig[cc].number)
                try:
                    plt.savefig(output_img_dir + txt + '_data.png')
                except:
                    pass
                finally:
                    plt.close(fig[cc])

            for ss in range(len(PBV_TO_CHECK)):
                plt.figure(fig[CC+2*ss].number)
                try:
                    plt.savefig(output_img_dir + 'pulse_spo2_{}.png'.format(PBV_TO_CHECK[ss]))
                except:
                    pass
                finally:
                    plt.close(fig[CC+2*ss])
                plt.figure(fig[CC+2*ss+1].number)
                try:
                    plt.savefig(output_img_dir + 'freq_spo2_{}.png'.format(PBV_TO_CHECK[ss]))
                except:
                    pass
                finally:
                    plt.close(fig[CC+2*ss+1])
        # End if we are saving plots.

        beats = freq[peak_freq_count.argmax()] * 60.0
        rospy.loginfo('{}: {:.1f} beats / min; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
            self.name, beats, msmt_n, ti, tf, (tf - ti) / msmt_n))

    def region_callback(self, data):
        if len(data.polygon.points) != 2:
            return

        xmin = int(data.polygon.points[0].x)
        ymin = int(data.polygon.points[0].y)
        xmax = int(data.polygon.points[1].x)
        ymax = int(data.polygon.points[1].y)
        if (xmax - xmin) <= 0 or (ymax - ymin) <= 0:
            return

        with self.lock:
            self.roi_buffer.append([data.header.stamp.to_sec(), xmin, ymin, xmax, ymax])

    def clear_buffers(self):
        # Measurement buffers
        self.t_buffer = []
        self.roi_buffer = []
        self.red_msmt_buffer = []
        self.nir_msmt_buffer = []
        self.blue_msmt_buffer = []

        self.start_msmt = True

    def clear_msmt_state(self):
        rospy.logwarn_throttle(1, '{}: Resetting'.format(self.name))

        # Tracking status
        self.tracking_status = False

        self.ti = None
        self.tf = None

        self.tlast = dict(red=None, nir=None, blue=None)
        self.delta = dict(red=None, nir=None, blue=None)

        self.clear_buffers()

    def __init__(self, name):
        self.name = name

        self.lock = threading.Lock()

        self.clear_msmt_state()

        # Software time delta calculation
        self.delta_alpha = 0.8

        self.bridge = CvBridge()

        self.msmt_pub = rospy.Publisher(MSMT_TOPIC, Float32, queue_size=10)
        self.data_pub = rospy.Publisher(DATA_TOPIC, Float32MultiArray, queue_size=10)

        self.red_image_sub = message_filters.Subscriber(RED_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.nir_image_sub = message_filters.Subscriber(NIR_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.blue_image_sub = message_filters.Subscriber(BLUE_IMAGE_TOPIC, Image,
                                                         queue_size=IMG_QUEUE_SIZE,
                                                         buff_size=IMG_BUF_SIZE)

        self.approx_image_sync = message_filters.ApproximateTimeSynchronizer([self.red_image_sub,
                                                                              self.nir_image_sub,
                                                                              self.blue_image_sub],
                                                                             200, 0.1)
        self.approx_image_sync.registerCallback(self.image_callback)

        self.region_sub = rospy.Subscriber(RED_FACE_IN_ROI_REGION_TOPIC, PolygonStamped,
                                           self.region_callback, queue_size=IMG_QUEUE_SIZE)

        self.tracking_status_sub = rospy.Subscriber(TRACKING_STATUS_TOPIC, Bool,
                                                    self.tracking_status_callback, queue_size=1)

        self.msmt_helper_timer = rospy.Timer(rospy.Duration(HELPER_TIMER_PERIOD_SEC),
                                             self.msmt_helper_callback)

if __name__ == '__main__':
    rospy.init_node('heart_rate')
    hr = HeartRate(rospy.get_name())
    rospy.spin()
