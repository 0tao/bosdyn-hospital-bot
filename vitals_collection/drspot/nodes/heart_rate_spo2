#!/usr/bin/env python

# Copyright 2020 Boston Dynamics Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

DEBUG_PLOT = False
DEBUG_IMAGE = False
DEBUG_SAVE_IMAGES = False
if DEBUG_PLOT:
    import matplotlib.pyplot as plt
if DEBUG_SAVE_IMAGES:
    LOG_DIR = '/log'
    import os
import time

import numpy as np
import threading
import cv2

import rospy
import message_filters
from sensor_msgs.msg import Image
from geometry_msgs.msg import PolygonStamped
from std_msgs.msg import Float32MultiArray, Float32, Bool
from cv_bridge import CvBridge

RED_IMAGE_TOPIC = 'mono_red_cropped'
NIR_IMAGE_TOPIC = 'mono_nir_cropped'
BLUE_IMAGE_TOPIC = 'mono_blue_cropped'

MSMT_TOPIC = 'full_heart_rate'
DATA_TOPIC = 'full_data_heart_rate'
TRACKING_STATUS_TOPIC = 'mono_red_tracking_status'
HELPER_TIMER_PERIOD_SEC = 1
FULL_MSMT_PERIOD_SEC = 10
OK_FRAC_MSMT = 0.7
MAX_DROPOUT_BEFORE_RESET_SEC = 0.5
# Buffer about 3 seconds of cropped frames.
IMG_QUEUE_SIZE = 3 * 35
IMG_BUF_SIZE = IMG_QUEUE_SIZE * 1000 * 1000

# Minimum of 30 beats per minute.
MIN_HEART_HZ = 30.0 / 60.0
# Maximum of 120 beats per minute.
MAX_HEART_HZ = 120.0 / 60.0

class HeartRate(object):
    def image_callback(self, red_image_data, nir_image_data, blue_image_data):
        with self.lock:
            chans = ((self.red_tlast, self.red_delta, red_image_data, 'red'),
                     (self.nir_tlast, self.nir_delta, nir_image_data, 'nir'),
                     (self.blue_tlast, self.blue_delta, blue_image_data, 'blue'))

            for tlast, delta, image_data, txt in chans:
                t = image_data.header.stamp.to_sec()

                if tlast is None:
                    tlast = t
                    return

                # Detect backward jumps in time in replay.
                if tlast > t:
                    clear_msmt_state()
                    tlast = t
                    rospy.logwarn('{} {}: Backward jump in time {:0.6f} vs {:0.6f}'.format(
                        self.name, txt, tlast, t))
                    return

                # Detect skips in data.
                if t - tlast > MAX_DROPOUT_BEFORE_RESET_SEC:
                    rospy.logwarn_throttle(1, '{} {}: Dropped samples for {} sec'.format(
                        self.name, txt, t - tlast))
                    self.clear_msmt_state()
                    tlast = t
                    return

                if delta is None:
                    delta = t - tlast
                    return

                delta = self.delta_alpha * (t - tlast) + (1 - self.delta_alpha) * delta
                tlast = t
        # End locked region.

        red_image = self.bridge.imgmsg_to_cv2(red_image_data,
                                              desired_encoding='passthrough')
        nir_image = self.bridge.imgmsg_to_cv2(nir_image_data,
                                              desired_encoding='passthrough')
        blue_image = self.bridge.imgmsg_to_cv2(blue_image_data,
                                               desired_encoding='passthrough')

        t = red_image_data.header.stamp.to_sec()
        with self.lock:
            if len(self.red_msmt_buffer) == 0: self.ti = t
            self.red_msmt_buffer.append(red_image)
            self.nir_msmt_buffer.append(nir_image)
            self.blue_msmt_buffer.append(blue_image)
            self.tf = t
        # End locked region.

    def tracking_status_callback(self, data):
        with self.lock:
            if not self.roi_valid or not data.data:
                # Clear the measurement buffer unless we are valid, staying valid.
                self.clear_msmt_state()
            self.roi_valid = data.data

    def msmt_helper_callback(self, event):
        with self.lock:
            if not self.roi_valid:
                rospy.logwarn_throttle(1, '{}: No valid ROI received.'.format(self.name))
                self.clear_msmt_state()
                return

            delta = self.red_delta

            ti = self.ti
            tf = self.tf
            red_data = list(self.red_msmt_buffer)
            nir_data = list(self.nir_msmt_buffer)
            blue_data = list(self.blue_msmt_buffer)
            do_it = ti is not None and tf is not None and tf - ti >= FULL_MSMT_PERIOD_SEC
            if do_it:
                self.red_msmt_buffer = []
                self.nir_msmt_buffer = []
                self.blue_msmt_buffer = []
        # End locked region.

        if do_it:
            msmt_n = len(red_data)
            rospy.loginfo('{}: starting computation; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
                self.name, msmt_n, ti, tf, (tf - ti) / msmt_n))
            # Spawn a thread to do the measurement.
            t = threading.Thread(target=self.msmt_callback, name='full_' + self.name,
                                 args=(event, ti, tf, red_data, nir_data, blue_data, delta))
            t.start()
            #self.msmt_callback(event, ti, tf, red_data, nir_data, blue_data, delta)
            with self.lock:
                self.red_msmt_buffer = []
                self.nir_msmt_buffer = []
                self.blue_msmt_buffer = []

    def msmt_callback(self, event, ti, tf, red_data, nir_data, blue_data, delta):
        msmt_n = len(red_data)

        if msmt_n != len(nir_data) or msmt_n != len(blue_data):
            rospy.logerror('{}: mismatched channels {} {} {}'.format(self.name, msmt_n,
                                                                     len(nir_data),
                                                                     len(blue_data)))
            return

        if delta is None or delta < 1e-3 or msmt_n < OK_FRAC_MSMT * FULL_MSMT_PERIOD_SEC / delta:
            rospy.loginfo_throttle(1, '{}: not enough samples {}'.format(self.name, msmt_n))
            return

        if DEBUG_SAVE_IMAGES:
            output_img_dir = LOG_DIR + os.path.sep + str(int(ti)) + os.path.sep
            os.mkdir(output_img_dir)

        beats = 0
        rospy.loginfo('{}: {:.1f} beats / min; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(
            self.name, beats, msmt_n, ti, tf, (tf - ti) / msmt_n))

    def clear_msmt_state(self):
        rospy.logwarn_throttle(1, '{}: Resetting'.format(self.name))

        # Region of Interest
        self.roi_valid = False

        self.ti = None
        self.tf = None

        self.red_tlast = None
        self.red_delta = None

        self.nir_tlast = None
        self.nir_delta = None

        self.blue_tlast = None
        self.blue_delta = None

    def __init__(self, name):
        self.name = name

        self.lock = threading.Lock()

        # Measurement buffers
        self.red_msmt_buffer = []
        self.nir_msmt_buffer = []
        self.blue_msmt_buffer = []

        self.clear_msmt_state()

        # Software time delta calculation
        self.delta_alpha = 0.8

        self.bridge = CvBridge()

        self.data_axes = None
        if DEBUG_PLOT:
            self.fig = plt.figure()
            self.data_axes = [self.fig.add_subplot(2, 3, i) for i in range(1, 7)]

        self.msmt_pub = rospy.Publisher(MSMT_TOPIC, Float32, queue_size=10)
        self.data_pub = rospy.Publisher(DATA_TOPIC, Float32MultiArray, queue_size=10)

        self.red_image_sub = message_filters.Subscriber(RED_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.nir_image_sub = message_filters.Subscriber(NIR_IMAGE_TOPIC, Image,
                                                        queue_size=IMG_QUEUE_SIZE,
                                                        buff_size=IMG_BUF_SIZE)
        self.blue_image_sub = message_filters.Subscriber(BLUE_IMAGE_TOPIC, Image,
                                                         queue_size=IMG_QUEUE_SIZE,
                                                         buff_size=IMG_BUF_SIZE)

        self.approx_image_sync = message_filters.ApproximateTimeSynchronizer([self.red_image_sub,
                                                                              self.nir_image_sub,
                                                                              self.blue_image_sub],
                                                                             200, 0.1)
        self.approx_image_sync.registerCallback(self.image_callback)

        self.tracking_status_sub = rospy.Subscriber(TRACKING_STATUS_TOPIC, Bool,
                                                    self.tracking_status_callback, queue_size=1)

        self.msmt_helper_timer = rospy.Timer(rospy.Duration(HELPER_TIMER_PERIOD_SEC),
                                             self.msmt_helper_callback)

if __name__ == '__main__':
    rospy.init_node('heart_rate')
    hr = HeartRate(rospy.get_name())
    if DEBUG_PLOT:
        while not rospy.is_shutdown():
            plt.show(block=False)
            plt.pause(0.5)
    else:
        rospy.spin()
