#!/usr/bin/env python

# Copyright 2020 Boston Dynamics Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np

import rospy
from sensor_msgs.msg import Image
from geometry_msgs.msg import PolygonStamped
from std_msgs.msg import Float32MultiArray, Float32
from cv_bridge import CvBridge

IMAGE_TOPIC = 'temperature_image'
FULL_TOPIC = 'full_skin_temp'
REPEAT_TOPIC = 'repeated_skin_temp'
FULL_DATA_TOPIC = 'full_data_skin_temp'
REPEAT_DATA_TOPIC = 'repeated_data_skin_temp'
REGION_TOPIC = 'skin_temp_roi'
REPEAT_MSMT_PERIOD_SEC = 5
FULL_MSMT_PERIOD_SEC = 10
NOMINAL_RATE_HZ = 27
NOMINAL_MIN_SAMPLES = REPEAT_MSMT_PERIOD_SEC * NOMINAL_RATE_HZ
NOMINAL_FULL_SAMPLES = FULL_MSMT_PERIOD_SEC * NOMINAL_RATE_HZ
OK_FRAC_MSMT = 0.7
MAX_DROPOUT_BEFORE_RESET_SEC = 0.2

ROS_THERMAL_IMAGE_BUFFER_SIZE = 640*480 * 2 * 3

class SkinTemperature(object):
    def image_callback(self, data):
        t = data.header.stamp.to_sec()
        if self.tlast is None:
            self.tlast = t
            return

        # Detect backward jumps in time in replay.
        if self.tlast > t:
            self.clear_msmt_state()
            self.tlast = t
            rospy.logwarn_throttle(1, 'Backward jump in time; resetting.')
            return

        # Detect skips in data.
        if t - self.tlast > MAX_DROPOUT_BEFORE_RESET_SEC:
            self.clear_msmt_state()
            self.tlast = t
            rospy.logwarn_throttle(1, 'Dropped samples; resetting.')
            return

        if self.delta is None:
            self.delta = t - self.tlast
            return

        self.delta = self.delta_alpha * (t - self.tlast) + (1 - self.delta_alpha) * self.delta
        self.tlast = t

        if not self.roiset:
            return

        cv_image = self.bridge.imgmsg_to_cv2(data, desired_encoding='passthrough')
        (rows, cols) = cv_image.shape

        if self.xmin < 0: self.xmin = 0
        if self.ymin < 0: self.ymin = 0
        if self.xmax >= cols: self.xmin = cols-1
        if self.ymax >= rows: self.ymin = rows-1

        try:
            val = np.amax(cv_image[self.xmin:self.xmax, self.ymin:self.ymax])
        except ValueError as e:
            rospy.logwarn_throttle(1, str(e))
            self.clear_msmt_state()
            return

        if (self.repeat_msmt_n >= self.repeat_msmt_buffer.size):
            self.repeat_msmt_buffer.resize((2 * self.repeat_msmt_buffer.size), refcheck=False)
        self.repeat_msmt_buffer[self.repeat_msmt_n] = val
        if self.repeat_msmt_n == 0: self.r_ti = t
        self.repeat_msmt_n += 1
        self.r_tf = t

        if (self.full_msmt_n >= self.full_msmt_buffer.size):
            self.full_msmt_buffer.resize((2 * self.full_msmt_buffer.size), refcheck=False)
        self.full_msmt_buffer[self.full_msmt_n] = val
        if self.full_msmt_n == 0: self.f_ti = t
        self.full_msmt_n += 1
        self.f_tf = t

    def region_callback(self, data):
        if len(data.polygon.points) != 2:
            return

        self.xmin = int(data.polygon.points[0].x)
        self.ymin = int(data.polygon.points[0].y)
        self.xmax = int(data.polygon.points[1].x)
        self.ymax = int(data.polygon.points[1].y)
        if (self.xmax - self.xmin) <= 0 and (self.ymax - self.ymin) <= 0:
            return

        self.roiset = True

        if self.full_msmt_timer is None:
            self.restart_full_measurement()

    def repeat_msmt_callback(self, event):
        data = self.repeat_msmt_buffer[0:self.repeat_msmt_n]
        if self.delta is None or self.delta < 1e-3 or data.shape[0] < OK_FRAC_MSMT * REPEAT_MSMT_PERIOD_SEC / self.delta:
            rospy.loginfo_throttle(1, 'repeated callback; not enough samples: {}'.format(data.shape[0]))
            self.repeat_msmt_n = 0
            return

        msg = Float32MultiArray()
        msg.data = data
        self.repeat_data_pub.publish(msg)

        mean = np.mean(data)
        rospy.loginfo('repeated: {:.1f} deg C; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(mean, data.shape[0], self.r_ti, self.r_tf, (self.r_tf - self.r_ti) / data.shape[0]))
        self.repeat_msmt_n = 0

        msg = Float32()
        msg.data = mean
        self.repeat_msmt_pub.publish(msg)

    def full_msmt_callback(self, event):
        data = self.full_msmt_buffer[0:self.full_msmt_n]
        if self.delta is None or self.delta < 1e-3 or data.shape[0] < OK_FRAC_MSMT * FULL_MSMT_PERIOD_SEC / self.delta:
            rospy.loginfo_throttle(1, 'full callback; not enough samples: {}'.format(data.shape[0]))
            return

        msg = Float32MultiArray()
        msg.data = data
        self.full_data_pub.publish(msg)

        mean = np.mean(data)
        rospy.loginfo('full: {:.1f} deg C; nsamp: {}; ti: {:.1f}; tf: {:.1f}; delta: {:.4f}'.format(mean, data.shape[0], self.f_ti, self.f_tf, (self.f_tf - self.f_ti) / data.shape[0]))
        self.full_msmt_timer = None

        msg = Float32()
        msg.data = mean
        self.full_msmt_pub.publish(msg)

    def clear_msmt_state(self):
        self.r_ti = None
        self.r_tf = None
        self.repeat_msmt_n = 0
        self.f_ti = None
        self.f_tf = None
        self.full_msmt_n = 0
        self.full_msmt_timer = None

        self.tlast = None
        self.delta = None

    def restart_full_measurement(self):
        self.full_msmt_timer = rospy.Timer(rospy.Duration(FULL_MSMT_PERIOD_SEC), self.full_msmt_callback, oneshot=True)
        self.full_msmt_n = 0

    def __init__(self, name):
        # Measurement buffers
        self.repeat_msmt_buffer = np.zeros(NOMINAL_MIN_SAMPLES)
        self.full_msmt_buffer = np.zeros(NOMINAL_FULL_SAMPLES)

        self.clear_msmt_state()

        # Region of Interest
        self.roiset = False
        self.xmin = 0
        self.xmax = 0
        self.ymin = 0
        self.ymax = 0

        # Software time delta calculation
        self.delta_alpha = 0.8

        self.bridge = CvBridge()

        self.full_msmt_pub = rospy.Publisher(FULL_TOPIC, Float32, queue_size=10)
        self.repeat_msmt_pub = rospy.Publisher(REPEAT_TOPIC, Float32, queue_size=10)
        self.full_data_pub = rospy.Publisher(FULL_DATA_TOPIC, Float32MultiArray, queue_size=10)
        self.repeat_data_pub = rospy.Publisher(REPEAT_DATA_TOPIC, Float32MultiArray, queue_size=10)

        self.image_sub = rospy.Subscriber(IMAGE_TOPIC, Image, self.image_callback, queue_size=1, buff_size=ROS_THERMAL_IMAGE_BUFFER_SIZE)
        self.region_sub = rospy.Subscriber(REGION_TOPIC, PolygonStamped, self.region_callback, queue_size=1)
        self.repeat_msmt_timer = rospy.Timer(rospy.Duration(REPEAT_MSMT_PERIOD_SEC), self.repeat_msmt_callback)

if __name__ == '__main__':
    rospy.init_node('skin_temperature')
    temp = SkinTemperature(rospy.get_name())
    rospy.spin()
